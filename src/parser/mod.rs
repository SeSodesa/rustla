/// This is the `parser` module of ruSTLa

mod state_machine;
use state_machine::StateMachine;

#[cfg(test)]
mod tests;

use std::io::{BufReader, Lines};
use std::fs::File;

use std::str;
use regex;

use crate::doctree::DocTree;

use std::collections;
use state_machine::states::{State};


pub struct Parser {
  machine_stack: Vec<StateMachine>,
}


/// Parser type methods
impl Parser {

  /// ### new
  /// The `Parser` constructor. Transforms the given source into a vector
  /// of `String`s, generates a `DocTree`, and passes these
  /// to the `StateMachine` at the top of the `Parser` machine stack,
  /// which is initialized in the `Body` `State`.
  fn new(source_line_iter: Lines<BufReader<File>>) -> Self {

    unimplemented!();

  }

  /// ### parse
  /// Starts the parsing process for a single file.
  /// Returns the `DocTree` generated by the `StateMachine`s.
  fn parse (&mut self){

  }

}


// /// ### val_from_key
// /// Goes through a given list of tuples
// /// ```
// /// (TokenType, str_pattern, Action)
// /// ```
// /// and looks for a matching tokentype.
// /// If it finds one, returns and `Option<&'static str>`,
// /// otherwise returns `None`.
// fn val_from_key(search_key: &TokenType, map: &[(TokenType, &'static str, Action)]) -> Option<&'static str> {
//   for (_, val, _) in map.iter().filter(|&(map_key, _, _)| map_key == search_key) { 
//     return Some(val);
//   }
//   None
// }
