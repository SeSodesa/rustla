/// This is the `parser` module of ruSTLa

mod state_machine;

use state_machine::{StateMachine, MachineWithState};

#[cfg(test)]
mod tests;

use std::cmp;
use std::io::{BufReader, Lines};
use std::fs::File;

use std::str;
use std::collections;

use regex;

use crate::doctree::DocTree;
use crate::utils;

/// ### Parser
/// The parser type. Contains an optional
/// source line vector and a document tree.
/// These are optional to facilitate their passing
/// to any state machine in `machine_stack` via
/// `std::option::Option::take`
/// without invalidating the fields.
pub struct Parser {
  src_lines: Vec<String>,
  current_line: usize,
  doctree: Option<DocTree>,
  machine_stack: Vec<Option<StateMachine>>,
}


/// ==============
/// Parser Methods
/// ==============
impl Parser {

  /// ### new
  /// The `Parser` constructor. Transforms a given source string
  /// into a vector of lines and wraps this and a given `DocTree`
  /// in `Option`s. This wrapping allows the passing of these to owned
  /// state machnes via swapping the optional contents
  /// to `None` before granting ownership of the original contents.
  fn new(src: String, doctree: DocTree) -> Self {

    Self {
      src_lines: src.lines().map(|s| s.to_string()).collect::<Vec<String>>(),
      current_line: 0,
      doctree: Some(doctree),
      machine_stack: Vec::with_capacity(2)
    }

  }

  /// ### parse
  /// Starts the parsing process for a single file.
  /// Returns the `DocTree` generated by the `StateMachine`s.
  fn parse (&mut self) -> Result<Option<DocTree>, &'static str>{

    let init_state = MachineWithState::new( );

    let init_machine = StateMachine::Body(init_state);

    self.machine_stack.push(Some(init_machine));

    // The parsing loop
    let dt = loop {

      let mut match_found = false;

      // Retrieving a clone of the transitions stored in the latest state
      // A clone is needed because the below for loop takes
      // ownership of a reference given to it, which would prevent us from
      // modifying the machine stack.
      let latest_state_transitions = if let Some(machine) = self.machine_stack.last() {
        // We need as_ref(), as unwrap() returns a reference to an Option and not the StateMachine itself
        let latest_state_transitions = if let Ok(transitions_ref) = machine.as_ref().unwrap().get_transitions(){
          transitions_ref.clone()
        } else {
          return Err("Parsing ended in Failure state.\n")
        };

        latest_state_transitions

      } else {
        break
      };

      // Iterating over a clone of the transitions
      for (pattern_name, regex, method) in latest_state_transitions.iter() {

        // Fetching a reference to current line
        let src_line: &str = match Parser::get_source_from_line(&self.src_lines, self.current_line) {
          Ok(line) => line,
          Err(e) => {
            eprintln!("{}", e);
            return Err("Parsing ended prematurely because of an unqualified move past EOF.\n")
          }
        };

        // Running the current line of text through a DFA compiled from a regex
        if regex.is_match(src_line) {

          match_found = true;

          let captures = regex.captures(src_line).unwrap();

          self.doctree = match method(&self.src_lines, &mut self.current_line, self.doctree.take(), captures, pattern_name) {
            Ok((opt_doctree, opt_next_state, )) => {
              if let Some(next_state) = opt_next_state {
                self.machine_stack.push(Some(next_state));
              }
              opt_doctree
            }
            Err(e) => {
              eprintln!("{} on line {}", e, self.current_line);
              return Err("An error was encountered while executing a transition method.\n");
            }
          };
        }

        if match_found {
          break
        }

      }

      // Transtition the latest machine to a general failure state if no match found...
      if !match_found {
        let mut last_machine = self.machine_stack.last_mut().unwrap().take(); // Take ownership of the Option-wrapped StateMachine for modification purposes
        last_machine = Some(last_machine.unwrap().to_failure()); // Transition the machine to a failure state
        self.machine_stack.last_mut().replace(&mut last_machine); // Place it back into the machine stack. The variable last_machine now contains None, which can be dropped
      }

      self.current_line += 1;

    };

    Ok(self.doctree.take())

  }

  /// ### match_line
  /// Attempts to match the current line to each pattern
  /// in the list of transitions in the current `State`.
  /// If no match is found, the current line number
  /// is returned in an `Err`. If a line is matched,
  /// attempts to run the transition|parsing method
  /// related to the matched pattern.
  fn match_line(&mut self) -> Result<(), String>{

    unimplemented!();

  }


  /// ### jump_to_line
  /// Attempts to move `self.current_line` to the given index.
  /// Return an `Err` if not successful.
  fn jump_to_line(&mut self, line: usize) -> Result<(), &'static str> {

    if line < self.src_lines.len() {
      self.current_line = line;
    } else {
      return Err("Attempted a move to a non-existent line.\nComputer says  no...\n")
    }

    Ok(())

  }


  /// ### nth_next_line
  /// Attempts to increment `self.current_line` by `n`.
  /// Returns nothing if successful, otherwise returns `Err(&str)`.
  /// The called must handle the `Err` case.
  fn nth_next_line(&mut self, n: usize) -> Result<(), &'static str> {

    self.current_line = match self.current_line.checked_add(n) {
      Some(value) => value,
      None =>
        return Err("Attempted indexing with integer overflow.\nComputer says no...\n")
    };

    if self.current_line > self.src_lines.len() {
      return Err("No such line number.\nComputer says no...\n")
    }

    Ok(())

  }


  /// ### nth_previous_line
  /// Attempts to decrement `self.current_line` by `n`.
  /// Returns nothing if successful, otherwise returns `Err(&str)`.
  /// The called must handle the `Err` case.
  fn nth_previous_line(&mut self, n: usize) -> Result<(), &'static str> {

    self.current_line = match self.current_line.checked_sub(n) {
      Some(value) => value,
      None =>
        return Err("Attempted indexing with integer overflow.\nComputer says no...\n")
    };

    if self.current_line > self.src_lines.len() {
      return Err("No such line number.\nComputer says no...\n")
    }

    Ok(())

  }


  /// ### DEFAULT_LINE_STEP
  /// The default step used by the functions
  /// `nth_{previous|next}_line`.
  const DEFAULT_LINE_STEP: usize = 1;


}



/// ===========================
/// Parser associated functions
/// ===========================
impl Parser {

  /// ### get_source_from_line
  /// Attempts to retrieve the source from a given line number.
  /// Returns an `Ok` clone of it if successful, else
  /// returns and `Err` with a message.
  fn get_source_from_line (src_lines: &Vec<String>, line_num: usize) -> Result <&str, String> {

    let src = match src_lines.get(line_num) {
      Some(line) => line.as_str(),
      None => return Err(format!("No such line number ({} out of bounds).\nComputer says no...\n", line_num))
    };

    Ok(src)

  }



  /// ### read_text_block
  /// Reads in an contiguous set of lines of text.
  /// A text block in rST terms is a set of lines
  /// separated from other elements by empty lines above and below.
  /// Checks for indentation:
  /// if indentation is not allowed but indentation is found,
  /// returns an error message in an `Err`.
  fn read_text_block(src_lines: &Vec<String>, start_line: usize, indent_allowed: Option<bool>) -> Result<Vec<String>, String> {

    // Default parameter for allowed indentation
    let indent_allowed = indent_allowed.unwrap_or(false);

    let mut line_num = start_line;
    let last_line = src_lines.len();

    let mut lines: Vec<String> = Vec::with_capacity(last_line - start_line);

    while line_num < last_line - 1 {

      let line: String = match src_lines.get(line_num) {
        Some(line) => line.clone(),
        None => return Err(format!("Text block could not be read because of line {}.\n", line_num))
      };

      if line.is_empty() {
        break
      }

      let has_indent: bool = match line.get(0..1) {
        Some(line) => {
          line.chars().next().unwrap().is_whitespace()
        },
        None => return Err(format!("The first character of line {} could not be read.", line_num))
      };

      if !indent_allowed && has_indent {
        return Err(format!("No indent allowed but indent found on line {}!\nComputer says no...\n", line_num))
      }

      lines.push(line.clone());

      line_num += 1;

    }

    lines.shrink_to_fit();

    Ok(lines)

  }


  /// ### read_indented_block
  /// Reads in a block of indented lines text.
  /// Determines the minimum level of indentation
  /// and uses it as a reference for ending the block.
  ///
  /// Returns a tuple
  /// ```rust
  /// {block: Vec<String>, min_indent<u32>, finished_with_blank: bool}
  /// ```
  /// if successful.
  fn read_indented_block (src_lines: &Vec<String>, start_line: Option<usize>, until_blank: Option<bool>,
    strip_indent: Option<bool>, block_indent: Option<usize>, first_indent: Option<usize>)
  -> Result<(Vec<String>, usize, bool), String> {

    if src_lines.is_empty() {
      return Err(String::from("An empty block of text was handed for parsing.\nComputer says no...\n"))
    }

    // Default function parameters
    let start_line = start_line.unwrap_or(0);
    let until_blank = until_blank.unwrap_or(false);
    let strip_indent = strip_indent.unwrap_or(true);

    let mut line_num = start_line;
    let last_line_num = src_lines.len();

    let mut block_lines: Vec<String> = Vec::with_capacity(last_line_num - start_line);

    // Setting the initial level of minimal indentation
    let mut minimal_indent = match block_indent {
      Some(indent) => Some(indent),
      None => None
    };

    eprintln!("Minimal indent after block assignment: {:?}", minimal_indent);

    // If there is block indentation but no predetermined indentation for the first line,
    // set the indentation of the first line equal to block indentation.
    let first_indent = if let (Some(block_indent), None) = (block_indent, first_indent) {
      eprintln!("Setting first line indentation equal to block indentation: {}...\n", block_indent);
      Some(block_indent)
    } else {
      first_indent
    };

    eprintln!("First indent set to {:?}", first_indent);

    // Push first line into `block_lines` and increment
    // line number to ignore indentation (for now) if first_indent was set
    if !first_indent.is_none() {
      eprintln!("Pushing line {} to block_lines", line_num);
      let line = src_lines.get(line_num).unwrap().to_owned();
      block_lines.push(line);
      line_num += 1;
    }

    let mut blank_finish: bool = false;

    let mut loop_broken = false; // Used to detect whether the below while loop was broken out of

    while line_num < last_line_num {

      let line: String = match src_lines.get(line_num) {
        Some(line) => line.clone(),
        None => return Err(format!("Line {} could not be read\nComputer says no...\n", line_num))
      };

      // Check for sufficient indentation
      for (i, c) in line.chars().enumerate() {

        // No need to keep looping if we have reached a
        // sufficient level of indentation
        if !block_indent.is_none() && i == block_indent.unwrap() {
          break
        }

        if !c.is_whitespace() && i == 0 // No indentation at all
          || (!block_indent.is_none() && i < block_indent.unwrap() && !c.is_whitespace()) // Not enough indentation
        {

          eprintln!("Not enough indentation!\n");

          // Block is valid, iff the last indented line is blank
          blank_finish = (line_num > start_line) &&
            src_lines
              .get(line_num - 1)
              .unwrap()
              .trim()
              .is_empty();

          eprintln!("Blank finish: {:?}", blank_finish);

          // end while iteration
          line_num = last_line_num;
          break

        }

      }

      if line_num >= last_line_num {
        eprintln!("Breaking out of while loop\n");
        loop_broken = true;
        break
      }

      // Trim beginning whitespace from line under observation
      // for blank line check
      let no_indent_line = line.trim_start();

      let line_indent: usize;

      // Updating the minimal level of indentation, if line isn't blank
      // and there isn't predetermined block indentation
      if no_indent_line.is_empty() && until_blank {

        blank_finish = true;
        break

      } else if block_indent.is_none() {

        line_indent = line.chars().count() - no_indent_line.chars().count();

        eprintln!("Line indent: {:?} on line {:?}", line_indent, line_num);

        if minimal_indent.is_none() {
          minimal_indent = Some(line_indent);
        } else if line_indent > 0 {
          minimal_indent = Some(cmp::min(minimal_indent.unwrap(), line_indent));
        } 

      }

      eprintln!("Minimal indent {:?} on line {:?}", minimal_indent, line_num);

      if !line.trim().is_empty() {
        block_lines.push(line);
      }

      line_num += 1;

    }

    eprintln!("Loop broken: {:?}\n", loop_broken);

    if !loop_broken {
      blank_finish = true;
    }

    // If indentation was expected on the first line, remove it
    if !first_indent.is_none() && !block_lines.is_empty() {

      eprintln!("Removing first line indentation...\n");

      if let Some(first_line) = block_lines.first_mut() {
        
        let mut cs = first_line.chars();

        for _i in 0..first_indent.unwrap() {
          cs.next();
        }

        let trunc_line = cs.as_str().to_string();

          *first_line = trunc_line;

      }
    }

    // Strip all minimal indentation from each line
    if let Some(indent) = minimal_indent {
      if strip_indent {

        eprintln!("Removing indentation from lines...\n");

        for (index, line) in block_lines.iter_mut().enumerate() {

          if first_indent.is_some() && index == 0 {
            eprintln!("Cursor currently on the first line of block and \nfirst line had own indentation.\nContinuing...\n");
            continue
          }

          eprintln!("Draining line {:?} of minimal indent, {:?}...", line, indent);

          let trunc_line = match utils::strip_indent(line.clone(), indent) {
            Ok(line) => line,
            Err(e) => {
              eprintln!("{}", e);
              return Err(format!("Indentation removal error on line {} of block under inspection\n", index));              
            }
          };

          *line = trunc_line;

          eprintln!("Line after drain: {:?}\n", line);
        }
      }
    }

    block_lines.shrink_to_fit(); // Free unnecessary used memory

    Ok((block_lines, minimal_indent.unwrap(), blank_finish))

  }

}


// /// ### val_from_key
// /// Goes through a given list of tuples
// /// ```
// /// (TokenType, str_pattern, Action)
// /// ```
// /// and looks for a matching tokentype.
// /// If it finds one, returns and `Option<&'static str>`,
// /// otherwise returns `None`.
// fn val_from_key(search_key: &TokenType, map: &[(TokenType, &'static str, Action)]) -> Option<&'static str> {
//   for (_, val, _) in map.iter().filter(|&(map_key, _, _)| map_key == search_key) { 
//     return Some(val);
//   }
//   None
// }
