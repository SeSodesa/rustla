/// This is the `parser` module of ruSTLa

mod state_machine;

use state_machine::{StateMachine, MachineWithState};

#[cfg(test)]
mod tests;

use std::io::{BufReader, Lines};
use std::fs::File;

use std::str;
use regex;

use crate::doctree::DocTree;

use std::collections;

/// ### Parser
/// The parser type. Contains an optional
/// source line vector and a document tree.
/// These are optional to facilitate their passing
/// to any state machine in `machine_stack` via
/// `std::option::Option::take`
/// without invalidating the fields.
pub struct Parser {
  src_lines: Vec<String>,
  current_line: usize,
  doctree: Option<DocTree>,
  machine_stack: Vec<StateMachine>,
}


/// Parser type methods
impl Parser {

  /// ### new
  /// The `Parser` constructor. Transforms a given source string
  /// into a vector of lines and wraps this and a given `DocTree`
  /// in `Option`s. This wrapping allows the passing of these to owned
  /// state machnes via swapping the optional contents
  /// to `None` before granting ownership of the original contents.
  fn new(src: String, doctree: DocTree) -> Self {

    Self {
      src_lines: src.lines().map(|s| s.to_string()).collect::<Vec<String>>(),
      current_line: 0,
      doctree: Some(doctree),
      machine_stack: Vec::with_capacity(2)
    }

  }

  /// ### parse
  /// Starts the parsing process for a single file.
  /// Returns the `DocTree` generated by the `StateMachine`s.
  fn parse (&mut self) -> Result<Option<DocTree>, &'static str>{

    let init_state = MachineWithState::new( );

    let init_machine = StateMachine::Body(init_state);

    self.machine_stack.push(init_machine);

    // The parsing loop
    let dt = loop {

      for (name, regex, method) in self.machine_stack.last().unwrap().get_transitions().iter() {

        let src_line: &str = match self.get_source_from_line(None) {
          Ok(line) => line,
          Err(e) => {
            eprintln!("{}", e);
            return Err("Parsing ended prematurely because of an unqualified move past EOF.\n")
          }
        };

        if regex.is_match(src_line) {
          self.doctree = match method(self.doctree.take()) {
            Ok(opt_doctree) => opt_doctree,
            Err(e) => {
              eprintln!("{}", e);
              return Err("An error was encountered while executing a transition method.\n");
            }
          };
        }

      }

      break

    };

    Ok(self.doctree.take())

  }

  /// ### match_line
  /// Attempts to match the current line to each pattern
  /// in the list of transitions in the current `State`.
  /// If no match is found, the current line number
  /// is returned in an `Err`. If a line is matched,
  /// attempts to run the transition|parsing method
  /// related to the matched pattern.
  fn match_line(&mut self) -> Result<(), String>{

    unimplemented!();

  }


  /// ### get_source_from_line
  /// Attempts to retrieve the source from a given line number.
  /// Returns an `Ok` clone of it if successful, else
  /// returns and `Err` with a message.
  fn get_source_from_line (&self, line_num: Option<usize>) -> Result <&str, String> {

    let line = line_num.unwrap_or(self.current_line);

    let src = match self.src_lines.get(line) {
      Some(line) => line.as_str(),
      None => return Err(format!("No such line number ({} out of bounds).\nComputer says no...\n", line))
    };

    Ok(src)

  }


  /// ### jump_to_line
  /// Attempts to move `self.current_line` to the given index.
  /// Return an `Err` if not successful.
  fn jump_to_line(&mut self, line: usize) -> Result<(), &'static str> {

    if line < self.src_lines.len() {
      self.current_line = line;
    } else {
      return Err("Attempted a move to a non-existent line.\nComputer says  no...\n")
    }

    Ok(())

  }


  /// ### nth_next_line
  /// Attempts to increment `self.current_line` by `n`.
  /// Returns nothing if successful, otherwise returns `Err(&str)`.
  /// The called must handle the `Err` case.
  fn nth_next_line(&mut self, n: usize) -> Result<(), &'static str> {

    self.current_line = match self.current_line.checked_add(n) {
      Some(value) => value,
      None =>
        return Err("Attempted indexing with integer overflow.\nComputer says no...\n")
    };

    if self.current_line > self.src_lines.len() {
      return Err("No such line number.\nComputer says no...\n")
    }

    Ok(())

  }


  /// ### nth_previous_line
  /// Attempts to decrement `self.current_line` by `n`.
  /// Returns nothing if successful, otherwise returns `Err(&str)`.
  /// The called must handle the `Err` case.
  fn nth_previous_line(&mut self, n: usize) -> Result<(), &'static str> {

    self.current_line = match self.current_line.checked_sub(n) {
      Some(value) => value,
      None =>
        return Err("Attempted indexing with integer overflow.\nComputer says no...\n")
    };

    if self.current_line > self.src_lines.len() {
      return Err("No such line number.\nComputer says no...\n")
    }

    Ok(())

  }


  /// ### DEFAULT_LINE_STEP
  /// The default step used by the functions
  /// `nth_{previous|next}_line`.
  const DEFAULT_LINE_STEP: usize = 1;


}


// /// ### val_from_key
// /// Goes through a given list of tuples
// /// ```
// /// (TokenType, str_pattern, Action)
// /// ```
// /// and looks for a matching tokentype.
// /// If it finds one, returns and `Option<&'static str>`,
// /// otherwise returns `None`.
// fn val_from_key(search_key: &TokenType, map: &[(TokenType, &'static str, Action)]) -> Option<&'static str> {
//   for (_, val, _) in map.iter().filter(|&(map_key, _, _)| map_key == search_key) { 
//     return Some(val);
//   }
//   None
// }
